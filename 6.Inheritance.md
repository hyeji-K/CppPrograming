# 상속

## 1. 기초 클래스와 파생 클래스
### 클래스의 상속
- 공통적인 멤버를 포함하는 유사한 유형의 클래스 
- 일반화와 특수화를 통한 클래스 계층구조 설계
- 파생 클래스 선언 형식

```C++
class DClassName : visibilitySpec BClassName {
visibilitySpec_1:
    데이터 멤버 또는 멤버함수 리스트;
visibilitySpec_2:
    데이터 멤버 또는 멤버함수 리스트;
};
```
- DClassName: 파생 클래스 이름
- BClassName: 기초 클래스 이름
- visibilitySpec: 가시성 지시어

- Person 클래스: 사람을 나타내는 클래스를 선언하고자 한다. 사람 객체는 이름을 가지고 있으며, 이름을 지정하거나 이름을 알릴 수 있다.
- Student 클래스: 학생을 나타내는 클래스를 선언하고자 한다. 학생 객체는 사람의 기능을 상속받으면서, 학교 이름을 지정하거나 저장된 학교 이름을 알리는 기능이 추가된다.

- 재정의(overriding)

### 클래스 계층
- 트리 구조
- 그래프 구조

## 2. 파생 클래스의 생성자 및 소멸자
- 생성자 선언 형식
```C++
DlassName(fParameterList) : BClassName(bArgsList) 
{
    ...... // 파생 클래스 생성자에서 추가되는 사항
};
```
- DlassName: 파생 클래스 생성자 - 파생 클래스 이름을 사용
- BClassName: 기초 클래스 생성자 - 기초 클래스 이름을 사용
- fParameterList: 파생 클래스 생성자 형식 매개변수 목록
- bArgsList: 기초 클래스 생성자에 전달할 인수 목록

### 생성자 및 소멸자의 실행 순서
- 생성자: 기초 클래스 생성자 -> 파생 클래스 생성자
    - 파생 클래스는 기초 클래스의 내용을 바탕으로 하고 있음
    -> 객체의 기초 클래스 해당 내용이 먼저 준비된 후 파생 클래스에 선언된 내용을 초기화할 필요가 있음
- 소멸자: 파생 클래스 소멸자 -> 기초 클래스 소멸자
    - 기초 클래스의 속성이 제거되기 전에 이를 활용할 가능성이 있는 파생 클래스 객체를 제거해야 함


## 3. 액세스 제어
### 가시성 지시어
| 가시성 지시어 | 공개 범위 |
| :-:| :-: |
| private(디폴트) | - 소속 클래스의 멤버함수 <br> - 친구 클래스의 멤버함수 및 친구함수 |
| protected | - 소속 클래스의 멤버함수 <br> - 친구 클래스의 멤버함수 및 친구 함수 <br> - 파생 클래스의 멤버함수 <br> - 파생 클래스의 친구 클래스의 멤버함수 및 친구함수 |
| public | - 전 범위 |

### 가시성의 상속
- 기초 클래스로부터 상속받은 멤버의 가시성
```C++
class DClassName : visibilitySpec BClassName {
    ......
};
```
- visibilitySpec: 기초 클래스로부터 상속된 멤버가 파생 클래스의 멤버로서 가지게 되는 가시성을 제어함
    - private, protected, public
    - class를 선언할 때는 private가 디폴트, struct를 선언할 떄는 public이 디폴트임
- visibilitySpec에 지시된 것이 가시성의 상한이 되도록 제한됨


## 4. 심화 
### final 클래스
- 파생 클래스 선언의 금지
    - final로 선언된 클래스는 파생 클래스를 더 이상 정의할 수 없음
    - final은 키워드가 아닌 식별자(identifier)임
        -> final 클래스 지정과 같이 특별히 정해진 위치에 사용되지 않은 경우 식별자의 용도로 사용할 수도 있음 (바람직한 용법은 아님)
        
### 이름 은폐(name hiding)
- 어떠한 영역에 선언된 이름을 그 영역에 내포된 영역에서 다시 선언하면 내포된 영역에서는 바깥 영역의 이름이 은폐됨
- 클래스 상속에서의 이름 은폐
    - 기초 클래스에 선언된 이름을 파생 클래스에서 재정의하면 파생 클래스의 객체에서 기초 클래스의 이름이 은폐됨


## 5. 상속과 포인터
### 클래스 계층구조와 포인터
- 포인터(참조)로 가리킬 수 있는 대상

- 객체 포인터의 배열 : Person 및 Student 클래스의 객체를 가리키는 포인터를 저장하는 배열을 선언하여 객체를 가리키게 하고 배열에 저장된 객체들을 출력하는 함수를 통해 출력하는 프로그램을 작성하라


## 6. 가상함수
### 객체 포인터와 재정의된 멤버함수 호출 
- 정적 연결

### 동적 연결(dynamic binding)
- 객체 포인터를 통해 객체의 멤버함수를 호출할 경우 포인터가 가리키는 실제 객체가 무엇인가에 따라 실행 중에 멤버함수를 결정하는 것
- C++에서는 가상함수(virtual function)로 동적 연결을 구현함
- 기초 클래스에서 가상함수로 선언한 멤버함수를 재정의한 파생 클래스의 함수는 역시 가상함수이며, 동적 연결이 적용됨

### 소멸자의 동적 연결
- 소멸자를 가상함수로 선언하지 않는다면?
    - 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 기초 클래스의 소멸자만 동작함
    -> 파생 클래스의 소멸자가 동작하지 않아 필요한 작업이 누락됨
- 소멸자를 가상함수로 선언
    - 기초 클래스의 포인터에 연결된 파생 클래스 객체를 제거할 때 파생 클래스의 소멸자가 동작할 수 있게 함

### 업 캐스팅과 다운 캐스팅
- 업 캐스팅(upcasting)
    - 파생 클래스 포인터를 기초 클래스 포인터로 변환하는 것
    - 묵시적 형 변환을 통해 업 캐스팅을 할 수 있음
- 다운 캐스팅(downcasting)
    - 기초 클래스 포인터를 파생 클래스 포인터로 변환하는 것
    - 묵시적 형 변환을 할 수 없으며, 형 변환 연산자로 명시적 형 변환을 해야 함 
- static_cast 연산자를 사용한 다운 캐스팅
    -> 부적절한 변환의 위험이 있음
- dynamic_cast 연산자를 사용한 다운 캐스팅
    -> 사용하려연 클래스 선언문에 가상함수를 포함하고 있어야 함

## 7. 심화
### override 
- 가상함수의 재정의
    - virtual은 기초 클래스의 가상함수를 재정의할 떄는 지정할 필요가 없으며, 파생 클래스에서 새롭게 가상함수를 선언하고자 할 때만 사용하는 것이 좋음
    - 파생 클래스에서 어떤 함수가 가상함수인지 명확히 알기 어려울 수 있으므로 가상함수를 재정의함을 명시적으로 알리고자 할 때는 'override'를 지정함 
```C++
class A {
    ......
    virtual void f() { }
};

class B : public A {
    ......
    void f() override { }
    virtual void g() { }
};
```

### final
- 가상함수의 재정의 금지
    - 가상함수를 더 이상 재정의하지 못하게 하려면 'final'을 지정함 
```C++
class A {
    ......
    virtual void f() { }
};

class B : public A {
    ......
    void f() override final { }
    virtual void g() { }
};

class C : public B {
    void f() override { } // error
}
```

## 8. 추상 클래스
### 추상 클래스와 상세 클래스
- 추상 클래스
    - 유사한 성격을 갖는 클래스들의 공통적 요소들을 뽑아서 만든 클래스로, 일부 메소드의 구체적 구현이 없어 직접적인 사례가 존재하지 않는 클래스
    - 추상 클래스로 객체를 직접 정의할 수 없음
        -> 추상 클래스는 그 자체로 사용되는 것이 아니라 파생 클래스를 통해 구현되어 사용됨
    - 사용 목적: 특정 그룹에 속하는 클래스들(추상 클래스의 파생 클래스들)이 반드시 가지고 있어야 할 행위를 지정함으로써 필요한 행위를 정의하는 것을 누락하지 않도록 함
    - Ex: 도형 클래스
        - 도형에 속하는 클래스(삼각형, 원 등)의 객체는 draw 및 move 등의 메소드가 정의되어 있어야 함을 지정함
        - 도형 클래스 자체는 draw 및 move 등의 메소드를 정의할 수 없어 객체를 만들 수 없음
- 상세 클래스
    - 클래스의 모든 요소가 구체적으로 구현되어 직접적인 사례가 존재하는 클래스
    - 상세 클래스는 객체를 정의할 수 있음
    - Ex: 삼각형 및 원 클래스
        - 추상 클래스인 '도형'에서 구현되지 않은 상태로 상속받은 draw, move 등을 구체적으로 정의할 수 있음
        -> 삼각형이나 원 클래스의 객체를 정의할 수 있음
- 멤버 함수 중 순수가상함수가 포함된 클래스를 선언

### 순수 가상함수: 구현 부분이 없는 가상함수
- 순수 가상함수의 선언
virtual RetType functionName(fParameterList) = 0;
```C++
class AClass {
public:
    virtual void vf() const = 0; // 순수 가상함수
    void f1() const 
    { cout << "Abstract" << endl; }
};
```
- AClass objA; -> error: 추상 클래스의 객체 정의 불가

### 상세 클래스의 선언
- 순수 가상함수를 포함하지 않는 클래스를 선언
    - 상속받은 순수가상함수가 있다면 반드시 재정의해야 함
```C++
class AClass {
public:
    virtual void vf() const = 0; // 순수 가상함수
};
class CClass : public AClass {
public:
    void vf() const { cout << "순수가상함수 구현" << endl; }
    void f2() const
    { cout << "Concrete" << endl; }
};
```
- CClass objC; -> OK: CClass는 상세 클래스

- 도형 클래스: 2차원 도형에 해당되는 원을 나타내는 클래스와 삼각형을 나타내는 클래스를 선언하고자 한다. 이 클래스들은 모두 공통적으로 도형이므로 도형을 그리기 위한 선의 색과 도형 내부를 채워 칠하기 위한 색을 속성으로 가지고 있어야 하며, 이러한 속성을 이용하여 그리는 방법을 설명할 수 있어야 한다. 또한 그래픽 객체를 (dx, dy)만큼 이동할 수 있으며, 2차원 좌표 원점을 기준으로 확대/축소하는 크기조정을 할 수 있다. 프로그램은 현재 속성이라는 객체가 있다. 속성 객체는 선의 색과 내부 영역을 칠하기 위한 색을 표현하며, 그 값을 설정하거나 읽어낼 수 있다. 도형 객체를 만들면 현재 속성에 따라 만들어진다. 또한 도형 객체의 선 색 및 채우기 색을 변경할 수 있다.


## 9. 다중상속
### 다중상속(multiple inheritance)란
- 2개 이상의 기초 클래스로부터 상속을 받는 것

### 다중상속에서 공통 기초 클래스의 중복 상속
- 다중상속의 결과 1개의 기초 클래스가 여러 번 상속됨
-> 가상 기초 클래스로 상속하여 중복 상속을 방지할 수 있음